16d8840f1c225e0329d26a19ba8f3abe
'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _emittery() {
  var data = _interopRequireDefault(require('emittery'));

  _emittery = function _emittery() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _throat() {
  var data = _interopRequireDefault(require('throat'));

  _throat = function _throat() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = require('jest-worker');

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _runTest = _interopRequireDefault(require('./runTest'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TEST_WORKER_PATH = require.resolve('./testWorker');

var TestRunner = /*#__PURE__*/function () {
  function TestRunner(globalConfig, context) {
    _classCallCheck(this, TestRunner);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_context', void 0);

    _defineProperty(this, 'eventEmitter', new (_emittery()["default"])());

    _defineProperty(this, '__PRIVATE_UNSTABLE_API_supportsEventEmitters__', true);

    _defineProperty(this, 'isSerial', void 0);

    this._globalConfig = globalConfig;
    this._context = context || {};
  }

  _createClass(TestRunner, [{
    key: "runTests",
    value: function () {
      var _runTests = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tests, watcher, onStart, onResult, onFailure, options) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return options.serial ? this._createInBandTestRun(tests, watcher, onStart, onResult, onFailure) : this._createParallelTestRun(tests, watcher, onStart, onResult, onFailure);

              case 2:
                return _context.abrupt("return", _context.sent);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function runTests(_x, _x2, _x3, _x4, _x5, _x6) {
        return _runTests.apply(this, arguments);
      }

      return runTests;
    }()
  }, {
    key: "_createInBandTestRun",
    value: function () {
      var _createInBandTestRun2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(tests, watcher, onStart, onResult, onFailure) {
        var _this = this;

        var mutex;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                process.env.JEST_WORKER_ID = '1';
                mutex = (0, _throat()["default"])(1);
                return _context3.abrupt("return", tests.reduce(function (promise, test) {
                  return mutex(function () {
                    return promise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                      var sendMessageToJest;
                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (!watcher.isInterrupted()) {
                                _context2.next = 2;
                                break;
                              }

                              throw new CancelRun();

                            case 2:
                              if (!onStart) {
                                _context2.next = 8;
                                break;
                              }

                              _context2.next = 5;
                              return onStart(test);

                            case 5:
                              return _context2.abrupt("return", (0, _runTest["default"])(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, undefined));

                            case 8:
                              // `deepCyclicCopy` used here to avoid mem-leak
                              sendMessageToJest = function sendMessageToJest(eventName, args) {
                                return _this.eventEmitter.emit(eventName, (0, _jestUtil().deepCyclicCopy)(args, {
                                  keepPrototype: false
                                }));
                              };

                              _context2.next = 11;
                              return _this.eventEmitter.emit('test-file-start', [test]);

                            case 11:
                              return _context2.abrupt("return", (0, _runTest["default"])(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, sendMessageToJest));

                            case 12:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }))).then(function (result) {
                      if (onResult) {
                        return onResult(test, result);
                      } else {
                        return _this.eventEmitter.emit('test-file-success', [test, result]);
                      }
                    })["catch"](function (err) {
                      if (onFailure) {
                        return onFailure(test, err);
                      } else {
                        return _this.eventEmitter.emit('test-file-failure', [test, err]);
                      }
                    });
                  });
                }, Promise.resolve()));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      function _createInBandTestRun(_x7, _x8, _x9, _x10, _x11) {
        return _createInBandTestRun2.apply(this, arguments);
      }

      return _createInBandTestRun;
    }()
  }, {
    key: "_createParallelTestRun",
    value: function () {
      var _createParallelTestRun2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(tests, watcher, onStart, onResult, onFailure) {
        var _this2 = this;

        var resolvers, _iterator, _step, test, worker, mutex, runTestInWorker, onError, onInterrupt, runAllTests, cleanup;

        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                resolvers = new Map();
                _iterator = _createForOfIteratorHelper(tests);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    test = _step.value;

                    if (!resolvers.has(test.context.config.name)) {
                      resolvers.set(test.context.config.name, {
                        config: test.context.config,
                        serializableModuleMap: test.context.moduleMap.toJSON()
                      });
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                worker = new (_jestWorker().Worker)(TEST_WORKER_PATH, {
                  exposedMethods: ['worker'],
                  forkOptions: {
                    stdio: 'pipe'
                  },
                  maxRetries: 3,
                  numWorkers: this._globalConfig.maxWorkers,
                  setupArgs: [{
                    serializableResolvers: Array.from(resolvers.values())
                  }]
                });
                if (worker.getStdout()) worker.getStdout().pipe(process.stdout);
                if (worker.getStderr()) worker.getStderr().pipe(process.stderr);
                mutex = (0, _throat()["default"])(this._globalConfig.maxWorkers); // Send test suites to workers continuously instead of all at once to track
                // the start time of individual tests.

                runTestInWorker = function runTestInWorker(test) {
                  return mutex( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
                    var promise;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            if (!watcher.isInterrupted()) {
                              _context4.next = 2;
                              break;
                            }

                            return _context4.abrupt("return", Promise.reject());

                          case 2:
                            if (!onStart) {
                              _context4.next = 7;
                              break;
                            }

                            _context4.next = 5;
                            return onStart(test);

                          case 5:
                            _context4.next = 9;
                            break;

                          case 7:
                            _context4.next = 9;
                            return _this2.eventEmitter.emit('test-file-start', [test]);

                          case 9:
                            promise = worker.worker({
                              config: test.context.config,
                              context: _objectSpread(_objectSpread({}, _this2._context), {}, {
                                changedFiles: _this2._context.changedFiles && Array.from(_this2._context.changedFiles),
                                sourcesRelatedToTestsInChangedFiles: _this2._context.sourcesRelatedToTestsInChangedFiles && Array.from(_this2._context.sourcesRelatedToTestsInChangedFiles)
                              }),
                              globalConfig: _this2._globalConfig,
                              path: test.path
                            });

                            if (promise.UNSTABLE_onCustomMessage) {
                              // TODO: Get appropriate type for `onCustomMessage`
                              promise.UNSTABLE_onCustomMessage(function (_ref3) {
                                var _ref4 = _slicedToArray(_ref3, 2),
                                    event = _ref4[0],
                                    payload = _ref4[1];

                                _this2.eventEmitter.emit(event, payload);
                              });
                            }

                            return _context4.abrupt("return", promise);

                          case 12:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  })));
                };

                onError = /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(err, test) {
                    return regeneratorRuntime.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            if (!onFailure) {
                              _context5.next = 5;
                              break;
                            }

                            _context5.next = 3;
                            return onFailure(test, err);

                          case 3:
                            _context5.next = 7;
                            break;

                          case 5:
                            _context5.next = 7;
                            return _this2.eventEmitter.emit('test-file-failure', [test, err]);

                          case 7:
                            if (err.type === 'ProcessTerminatedError') {
                              console.error('A worker process has quit unexpectedly! ' + 'Most likely this is an initialization error.');
                              (0, _exit()["default"])(1);
                            }

                          case 8:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function onError(_x17, _x18) {
                    return _ref5.apply(this, arguments);
                  };
                }();

                onInterrupt = new Promise(function (_, reject) {
                  watcher.on('change', function (state) {
                    if (state.interrupted) {
                      reject(new CancelRun());
                    }
                  });
                });
                runAllTests = Promise.all(tests.map(function (test) {
                  return runTestInWorker(test).then(function (result) {
                    if (onResult) {
                      return onResult(test, result);
                    } else {
                      return _this2.eventEmitter.emit('test-file-success', [test, result]);
                    }
                  })["catch"](function (error) {
                    return onError(error, test);
                  });
                }));

                cleanup = /*#__PURE__*/function () {
                  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
                    var _yield$worker$end, forceExited;

                    return regeneratorRuntime.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return worker.end();

                          case 2:
                            _yield$worker$end = _context6.sent;
                            forceExited = _yield$worker$end.forceExited;

                            if (forceExited) {
                              console.error(_chalk()["default"].yellow('A worker process has failed to exit gracefully and has been force exited. ' + 'This is likely caused by tests leaking due to improper teardown. ' + 'Try running with --detectOpenHandles to find leaks.'));
                            }

                          case 5:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee6);
                  }));

                  return function cleanup() {
                    return _ref6.apply(this, arguments);
                  };
                }();

                return _context7.abrupt("return", Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup));

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _createParallelTestRun(_x12, _x13, _x14, _x15, _x16) {
        return _createParallelTestRun2.apply(this, arguments);
      }

      return _createParallelTestRun;
    }()
  }, {
    key: "on",
    value: function on(eventName, listener) {
      return this.eventEmitter.on(eventName, listener);
    }
  }]);

  return TestRunner;
}();

exports["default"] = TestRunner;

var CancelRun = /*#__PURE__*/function (_Error) {
  _inherits(CancelRun, _Error);

  var _super = _createSuper(CancelRun);

  function CancelRun(message) {
    var _this3;

    _classCallCheck(this, CancelRun);

    _this3 = _super.call(this, message);
    _this3.name = 'CancelRun';
    return _this3;
  }

  return CancelRun;
}( /*#__PURE__*/_wrapNativeSuper(Error));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2NoYWxrIiwiZGF0YSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX2VtaXR0ZXJ5IiwiX2V4aXQiLCJfdGhyb2F0IiwiX2plc3RVdGlsIiwiX2plc3RXb3JrZXIiLCJfcnVuVGVzdCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJfZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJURVNUX1dPUktFUl9QQVRIIiwicmVzb2x2ZSIsIlRlc3RSdW5uZXIiLCJnbG9iYWxDb25maWciLCJjb250ZXh0IiwiX2dsb2JhbENvbmZpZyIsIl9jb250ZXh0IiwidGVzdHMiLCJ3YXRjaGVyIiwib25TdGFydCIsIm9uUmVzdWx0Iiwib25GYWlsdXJlIiwib3B0aW9ucyIsInNlcmlhbCIsIl9jcmVhdGVJbkJhbmRUZXN0UnVuIiwiX2NyZWF0ZVBhcmFsbGVsVGVzdFJ1biIsInByb2Nlc3MiLCJlbnYiLCJKRVNUX1dPUktFUl9JRCIsIm11dGV4IiwicmVkdWNlIiwicHJvbWlzZSIsInRlc3QiLCJ0aGVuIiwiaXNJbnRlcnJ1cHRlZCIsIkNhbmNlbFJ1biIsInBhdGgiLCJjb25maWciLCJyZXNvbHZlciIsInVuZGVmaW5lZCIsInNlbmRNZXNzYWdlVG9KZXN0IiwiZXZlbnROYW1lIiwiYXJncyIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJkZWVwQ3ljbGljQ29weSIsImtlZXBQcm90b3R5cGUiLCJyZXN1bHQiLCJlcnIiLCJQcm9taXNlIiwicmVzb2x2ZXJzIiwiTWFwIiwiaGFzIiwibmFtZSIsInNldCIsInNlcmlhbGl6YWJsZU1vZHVsZU1hcCIsIm1vZHVsZU1hcCIsInRvSlNPTiIsIndvcmtlciIsIldvcmtlciIsImV4cG9zZWRNZXRob2RzIiwiZm9ya09wdGlvbnMiLCJzdGRpbyIsIm1heFJldHJpZXMiLCJudW1Xb3JrZXJzIiwibWF4V29ya2VycyIsInNldHVwQXJncyIsInNlcmlhbGl6YWJsZVJlc29sdmVycyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFN0ZG91dCIsInBpcGUiLCJzdGRvdXQiLCJnZXRTdGRlcnIiLCJzdGRlcnIiLCJydW5UZXN0SW5Xb3JrZXIiLCJyZWplY3QiLCJjaGFuZ2VkRmlsZXMiLCJzb3VyY2VzUmVsYXRlZFRvVGVzdHNJbkNoYW5nZWRGaWxlcyIsIlVOU1RBQkxFX29uQ3VzdG9tTWVzc2FnZSIsImV2ZW50IiwicGF5bG9hZCIsIm9uRXJyb3IiLCJ0eXBlIiwiY29uc29sZSIsImVycm9yIiwib25JbnRlcnJ1cHQiLCJfIiwib24iLCJzdGF0ZSIsImludGVycnVwdGVkIiwicnVuQWxsVGVzdHMiLCJhbGwiLCJtYXAiLCJjbGVhbnVwIiwiZW5kIiwiZm9yY2VFeGl0ZWQiLCJ5ZWxsb3ciLCJyYWNlIiwibGlzdGVuZXIiLCJtZXNzYWdlIiwiRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sV0FBUCxHQUFrQixLQUFLLENBQXZCOztBQUVBLFNBQVNFLE1BQVQsR0FBa0I7QUFDaEIsTUFBTUMsSUFBSSxHQUFHQyxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLE9BQUQsQ0FBUixDQUFuQzs7QUFFQUgsRUFBQUEsTUFBTSxHQUFHLGtCQUFZO0FBQ25CLFdBQU9DLElBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9BLElBQVA7QUFDRDs7QUFFRCxTQUFTRyxTQUFULEdBQXFCO0FBQ25CLE1BQU1ILElBQUksR0FBR0Msc0JBQXNCLENBQUNDLE9BQU8sQ0FBQyxVQUFELENBQVIsQ0FBbkM7O0FBRUFD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RCxTQUFyQixFQUFnQzJELFFBQWhDLENBQVA7QUFDRDs7Ozs7O0FBR0g3RyxPQUFPLFdBQVAsR0FBa0JxQixVQUFsQjs7SUFFTXVCLFM7Ozs7O0FBQ0oscUJBQVlrRSxPQUFaLEVBQXFCO0FBQUE7O0FBQUE7O0FBQ25CLCtCQUFNQSxPQUFOO0FBQ0EsV0FBS2hELElBQUwsR0FBWSxXQUFaO0FBRm1CO0FBR3BCOzs7aUNBSnFCaUQsSyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jaGFsaygpIHtcbiAgY29uc3QgZGF0YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZSgnY2hhbGsnKSk7XG5cbiAgX2NoYWxrID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfZW1pdHRlcnkoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2VtaXR0ZXJ5JykpO1xuXG4gIF9lbWl0dGVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2V4aXQoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ2V4aXQnKSk7XG5cbiAgX2V4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF90aHJvYXQoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoJ3Rocm9hdCcpKTtcblxuICBfdGhyb2F0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfamVzdFV0aWwoKSB7XG4gIGNvbnN0IGRhdGEgPSByZXF1aXJlKCdqZXN0LXV0aWwnKTtcblxuICBfamVzdFV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9qZXN0V29ya2VyKCkge1xuICBjb25zdCBkYXRhID0gcmVxdWlyZSgnamVzdC13b3JrZXInKTtcblxuICBfamVzdFdvcmtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxudmFyIF9ydW5UZXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKCcuL3J1blRlc3QnKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ZGVmYXVsdDogb2JqfTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5jb25zdCBURVNUX1dPUktFUl9QQVRIID0gcmVxdWlyZS5yZXNvbHZlKCcuL3Rlc3RXb3JrZXInKTtcblxuY2xhc3MgVGVzdFJ1bm5lciB7XG4gIGNvbnN0cnVjdG9yKGdsb2JhbENvbmZpZywgY29udGV4dCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2dsb2JhbENvbmZpZycsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgJ19jb250ZXh0Jywgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZXZlbnRFbWl0dGVyJywgbmV3IChfZW1pdHRlcnkoKS5kZWZhdWx0KSgpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHRoaXMsXG4gICAgICAnX19QUklWQVRFX1VOU1RBQkxFX0FQSV9zdXBwb3J0c0V2ZW50RW1pdHRlcnNfXycsXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNTZXJpYWwnLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fZ2xvYmFsQ29uZmlnID0gZ2xvYmFsQ29uZmlnO1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuICB9XG5cbiAgYXN5bmMgcnVuVGVzdHModGVzdHMsIHdhdGNoZXIsIG9uU3RhcnQsIG9uUmVzdWx0LCBvbkZhaWx1cmUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgKG9wdGlvbnMuc2VyaWFsXG4gICAgICA/IHRoaXMuX2NyZWF0ZUluQmFuZFRlc3RSdW4odGVzdHMsIHdhdGNoZXIsIG9uU3RhcnQsIG9uUmVzdWx0LCBvbkZhaWx1cmUpXG4gICAgICA6IHRoaXMuX2NyZWF0ZVBhcmFsbGVsVGVzdFJ1bihcbiAgICAgICAgICB0ZXN0cyxcbiAgICAgICAgICB3YXRjaGVyLFxuICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgb25SZXN1bHQsXG4gICAgICAgICAgb25GYWlsdXJlXG4gICAgICAgICkpO1xuICB9XG5cbiAgYXN5bmMgX2NyZWF0ZUluQmFuZFRlc3RSdW4odGVzdHMsIHdhdGNoZXIsIG9uU3RhcnQsIG9uUmVzdWx0LCBvbkZhaWx1cmUpIHtcbiAgICBwcm9jZXNzLmVudi5KRVNUX1dPUktFUl9JRCA9ICcxJztcbiAgICBjb25zdCBtdXRleCA9ICgwLCBfdGhyb2F0KCkuZGVmYXVsdCkoMSk7XG4gICAgcmV0dXJuIHRlc3RzLnJlZHVjZShcbiAgICAgIChwcm9taXNlLCB0ZXN0KSA9PlxuICAgICAgICBtdXRleCgoKSA9PlxuICAgICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHdhdGNoZXIuaXNJbnRlcnJ1cHRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENhbmNlbFJ1bigpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGV0IHNlbmRNZXNzYWdlVG9KZXN0OyAvLyBSZW1vdmUgYGlmKG9uU3RhcnQpYCBpbiBKZXN0IDI3XG5cbiAgICAgICAgICAgICAgaWYgKG9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblN0YXJ0KHRlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3J1blRlc3QuZGVmYXVsdCkoXG4gICAgICAgICAgICAgICAgICB0ZXN0LnBhdGgsXG4gICAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxDb25maWcsXG4gICAgICAgICAgICAgICAgICB0ZXN0LmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgICAgICAgdGVzdC5jb250ZXh0LnJlc29sdmVyLFxuICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYGRlZXBDeWNsaWNDb3B5YCB1c2VkIGhlcmUgdG8gYXZvaWQgbWVtLWxlYWtcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZVRvSmVzdCA9IChldmVudE5hbWUsIGFyZ3MpID0+XG4gICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KFxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICgwLCBfamVzdFV0aWwoKS5kZWVwQ3ljbGljQ29weSkoYXJncywge1xuICAgICAgICAgICAgICAgICAgICAgIGtlZXBQcm90b3R5cGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLXN0YXJ0JywgW3Rlc3RdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9ydW5UZXN0LmRlZmF1bHQpKFxuICAgICAgICAgICAgICAgICAgdGVzdC5wYXRoLFxuICAgICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgIHRlc3QuY29udGV4dC5yZXNvbHZlcixcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZVRvSmVzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICBpZiAob25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb25SZXN1bHQodGVzdCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLXN1Y2Nlc3MnLCBbXG4gICAgICAgICAgICAgICAgICB0ZXN0LFxuICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbkZhaWx1cmUodGVzdCwgZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLWZhaWx1cmUnLCBbdGVzdCwgZXJyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICk7XG4gIH1cblxuICBhc3luYyBfY3JlYXRlUGFyYWxsZWxUZXN0UnVuKHRlc3RzLCB3YXRjaGVyLCBvblN0YXJ0LCBvblJlc3VsdCwgb25GYWlsdXJlKSB7XG4gICAgY29uc3QgcmVzb2x2ZXJzID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCB0ZXN0IG9mIHRlc3RzKSB7XG4gICAgICBpZiAoIXJlc29sdmVycy5oYXModGVzdC5jb250ZXh0LmNvbmZpZy5uYW1lKSkge1xuICAgICAgICByZXNvbHZlcnMuc2V0KHRlc3QuY29udGV4dC5jb25maWcubmFtZSwge1xuICAgICAgICAgIGNvbmZpZzogdGVzdC5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICBzZXJpYWxpemFibGVNb2R1bGVNYXA6IHRlc3QuY29udGV4dC5tb2R1bGVNYXAudG9KU09OKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd29ya2VyID0gbmV3IChfamVzdFdvcmtlcigpLldvcmtlcikoVEVTVF9XT1JLRVJfUEFUSCwge1xuICAgICAgZXhwb3NlZE1ldGhvZHM6IFsnd29ya2VyJ10sXG4gICAgICBmb3JrT3B0aW9uczoge1xuICAgICAgICBzdGRpbzogJ3BpcGUnXG4gICAgICB9LFxuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIG51bVdvcmtlcnM6IHRoaXMuX2dsb2JhbENvbmZpZy5tYXhXb3JrZXJzLFxuICAgICAgc2V0dXBBcmdzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzZXJpYWxpemFibGVSZXNvbHZlcnM6IEFycmF5LmZyb20ocmVzb2x2ZXJzLnZhbHVlcygpKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gICAgaWYgKHdvcmtlci5nZXRTdGRvdXQoKSkgd29ya2VyLmdldFN0ZG91dCgpLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgIGlmICh3b3JrZXIuZ2V0U3RkZXJyKCkpIHdvcmtlci5nZXRTdGRlcnIoKS5waXBlKHByb2Nlc3Muc3RkZXJyKTtcbiAgICBjb25zdCBtdXRleCA9ICgwLCBfdGhyb2F0KCkuZGVmYXVsdCkodGhpcy5fZ2xvYmFsQ29uZmlnLm1heFdvcmtlcnMpOyAvLyBTZW5kIHRlc3Qgc3VpdGVzIHRvIHdvcmtlcnMgY29udGludW91c2x5IGluc3RlYWQgb2YgYWxsIGF0IG9uY2UgdG8gdHJhY2tcbiAgICAvLyB0aGUgc3RhcnQgdGltZSBvZiBpbmRpdmlkdWFsIHRlc3RzLlxuXG4gICAgY29uc3QgcnVuVGVzdEluV29ya2VyID0gdGVzdCA9PlxuICAgICAgbXV0ZXgoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAod2F0Y2hlci5pc0ludGVycnVwdGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfSAvLyBSZW1vdmUgYGlmKG9uU3RhcnQpYCBpbiBKZXN0IDI3XG5cbiAgICAgICAgaWYgKG9uU3RhcnQpIHtcbiAgICAgICAgICBhd2FpdCBvblN0YXJ0KHRlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Rlc3QtZmlsZS1zdGFydCcsIFt0ZXN0XSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gd29ya2VyLndvcmtlcih7XG4gICAgICAgICAgY29uZmlnOiB0ZXN0LmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2NvbnRleHQsXG4gICAgICAgICAgICBjaGFuZ2VkRmlsZXM6XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2hhbmdlZEZpbGVzICYmXG4gICAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5fY29udGV4dC5jaGFuZ2VkRmlsZXMpLFxuICAgICAgICAgICAgc291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXM6XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc291cmNlc1JlbGF0ZWRUb1Rlc3RzSW5DaGFuZ2VkRmlsZXMgJiZcbiAgICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9jb250ZXh0LnNvdXJjZXNSZWxhdGVkVG9UZXN0c0luQ2hhbmdlZEZpbGVzKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2xvYmFsQ29uZmlnOiB0aGlzLl9nbG9iYWxDb25maWcsXG4gICAgICAgICAgcGF0aDogdGVzdC5wYXRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwcm9taXNlLlVOU1RBQkxFX29uQ3VzdG9tTWVzc2FnZSkge1xuICAgICAgICAgIC8vIFRPRE86IEdldCBhcHByb3ByaWF0ZSB0eXBlIGZvciBgb25DdXN0b21NZXNzYWdlYFxuICAgICAgICAgIHByb21pc2UuVU5TVEFCTEVfb25DdXN0b21NZXNzYWdlKChbZXZlbnQsIHBheWxvYWRdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSk7XG5cbiAgICBjb25zdCBvbkVycm9yID0gYXN5bmMgKGVyciwgdGVzdCkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGBpZihvbkZhaWx1cmUpYCBpbiBKZXN0IDI3XG4gICAgICBpZiAob25GYWlsdXJlKSB7XG4gICAgICAgIGF3YWl0IG9uRmFpbHVyZSh0ZXN0LCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLWZhaWx1cmUnLCBbdGVzdCwgZXJyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gJ1Byb2Nlc3NUZXJtaW5hdGVkRXJyb3InKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0Egd29ya2VyIHByb2Nlc3MgaGFzIHF1aXQgdW5leHBlY3RlZGx5ISAnICtcbiAgICAgICAgICAgICdNb3N0IGxpa2VseSB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGVycm9yLidcbiAgICAgICAgKTtcbiAgICAgICAgKDAsIF9leGl0KCkuZGVmYXVsdCkoMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uSW50ZXJydXB0ID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgd2F0Y2hlci5vbignY2hhbmdlJywgc3RhdGUgPT4ge1xuICAgICAgICBpZiAoc3RhdGUuaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgICByZWplY3QobmV3IENhbmNlbFJ1bigpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgcnVuQWxsVGVzdHMgPSBQcm9taXNlLmFsbChcbiAgICAgIHRlc3RzLm1hcCh0ZXN0ID0+XG4gICAgICAgIHJ1blRlc3RJbldvcmtlcih0ZXN0KVxuICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBpZiAob25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9uUmVzdWx0KHRlc3QsIHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgndGVzdC1maWxlLXN1Y2Nlc3MnLCBbXG4gICAgICAgICAgICAgICAgdGVzdCxcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gb25FcnJvcihlcnJvciwgdGVzdCkpXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IGNsZWFudXAgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7Zm9yY2VFeGl0ZWR9ID0gYXdhaXQgd29ya2VyLmVuZCgpO1xuXG4gICAgICBpZiAoZm9yY2VFeGl0ZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBfY2hhbGsoKS5kZWZhdWx0LnllbGxvdyhcbiAgICAgICAgICAgICdBIHdvcmtlciBwcm9jZXNzIGhhcyBmYWlsZWQgdG8gZXhpdCBncmFjZWZ1bGx5IGFuZCBoYXMgYmVlbiBmb3JjZSBleGl0ZWQuICcgK1xuICAgICAgICAgICAgICAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRlc3RzIGxlYWtpbmcgZHVlIHRvIGltcHJvcGVyIHRlYXJkb3duLiAnICtcbiAgICAgICAgICAgICAgJ1RyeSBydW5uaW5nIHdpdGggLS1kZXRlY3RPcGVuSGFuZGxlcyB0byBmaW5kIGxlYWtzLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bkFsbFRlc3RzLCBvbkludGVycnVwdF0pLnRoZW4oY2xlYW51cCwgY2xlYW51cCk7XG4gIH1cblxuICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRFbWl0dGVyLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRlc3RSdW5uZXI7XG5cbmNsYXNzIENhbmNlbFJ1biBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdDYW5jZWxSdW4nO1xuICB9XG59XG4iXX0=